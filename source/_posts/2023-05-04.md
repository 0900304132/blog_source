---
title: '2023-05-04'
date: 2023-05-04 14:32:33
tags: ['正则']
categories: ['前端']
---

# 正则表达式

正则表达式, 尝尝缩写为"regex"或"regexp", 是帮助程序员匹配 搜索喝替换文本的模式. 正则表达式非常强大, 但可能难以阅读, 因为它们使用特殊字符来做更复杂更灵活的匹配.

## 使用测试方式

`/regex/.test('string')`

## 匹配文字字符串

`/abc/`

## 同时用多种模式匹配文字字符串

`/dog|cat|bird|fish/`

## 匹配时忽略大小写

`/freeCodeCamp/i`

## 提取匹配项

`'string'.match(/regex/)`

## 全局匹配

`/search/gi`

## 使用通配符匹配任何内容

`/.un/` 可以匹配 run、sun、fun、pun、num、bun

## 将单个字符与多种可能性匹配

`/b[aiu]g/`

## 匹配字母表中的字母

`/[a-e]at/` 匹配 cat bat mat

## 匹配字母表中的数字和字母

`/[a-z0-9]/ig`

## 匹配单个未指定的字符

`/[^aeiou]gi/` 匹配所有非元音字符

## 匹配出现一次或多次的字符

`/a+/g` 匹配出现一次或连续多次的字符 a(至少出现一次)

## 匹配出现零次或多次的字符

`/go*/`

## 用惰性匹配来查找字符

在正则表达式中, 贪婪(greedy)匹配会匹配到符合正则表达式匹配模式的字符串的最长可能部分.

可以使用`?`字符来讲起变成惰性匹配.

`t[a-z]*?i/` 匹配字符串 `"titanic"` 返回 `["ti"]`, 如果没有`?`, 则返回`["titani"]`

## 匹配字符串的开头

`/^Ricky/` 可以匹配 `"Ricky is first and can be found. "` 不能匹配 `"You can't find Ricky now."`

## 匹配字符串的末尾

`/story$/` 可以匹配 `"This is a never ending story"` 不能匹配 `"Sometimes a story will have to end"`

## 匹配所有的字母和数字

`/\w/` 这个缩写等同于 `/[A-Za-z0-9_]/`

## 匹配除了字母和数字的所有符号

`/\W/`

可以使用`\W`搜寻和`\w`相反的匹配模式. 注意, 相反匹配模式使用大写字母. 此缩写与`[^A-Za-z0-9_]`是一样的.

## 匹配所有数字

`\d` 等同于元字符`[0-9]`

## 匹配所有非数字

`\D` 等同于字符串`[^0-9]`

## 匹配空白字符

可以使用`\s`搜寻空格, 其中`s`是小写. 此匹配模式将匹配空格,回车符,制表符,换页符和换行符. 可以认为类似于元字符`[\r\t\f\n\v]`

## 匹配非空白字符

使用`\S`搜寻非空白字符, 其中`s`是大写. 此匹配模式将不匹配空格, 回车符, 制表符, 换行符和换页符. 可以认为这类似于元字符`[^\r\t\f\n\v]`

## 指定匹配的上限和下限

要匹配出现 3 到 5 次字母`a`在字符串`ah`, 正则表达式应为`/a{3,5}h/`

## 只指定匹配的下限

要匹配至少出现 3 次的字母`a`的字符串`hah`, 正则表达式应该是`/ha{3,}h/`

## 指定匹配的确切数量

要匹配字母`a`出现 3 次的单词`hah`, 正则表达式应为`/ha{3}h/`

## 检查全部或无

`/colou?r/` 可以匹配 `"colour"` 和 `"color"`, u 是可选的.

## 正向先行断言和负向先行断言

正向先行断言会查看并确保搜索模式中的元素存在, 但实际上并不匹配. 正向先行断言的用法是`(?=...)`, 其中`...`就是需要存在但不会匹配的部分.

另一方面, 负向先行断言会查看并确保搜索模式中的元素**不**存在. 负向先行断言的用法是`(?!...)`, 其中`...`是希望不存在的匹配模式. 如果负向先行断言部分不存在, 将返回匹配模式的其余部分.

一个简单的密码检查器, 密码的规则是 3 到 6 个字符而且至少要包含一个数字: 正则可以这样写`/(?=\w{3,6})(?=\D*\d)/`

## 检查混合字符组

如果想在字符串找到`Penguin`或`Pumpkin`, 可以用这个正则表达式: `/P(engu|umpk)in/g`

## 使用捕获组重用模式

```js
let repeatStr = 'row row row your boat'
let repeatRegex = /(\w+) \1 \1/

repeatRegex.test(repeatStr) // Returns true
repeatStr.match(repeatRegex) // Returns ["row row row", "row"]
```

捕获组是通过要把捕获的正则表达式放在括号中来构建.
分组匹配的子字符串被保存到一个临时的"变量", 可以使用同一正则表达式和反斜线及捕获组的编号来访问它(例如:`\1`). 捕获组按其开头括号的位置自动编号, 从 1 开始.

## 使用捕获组搜索和替换

```js
'Code Camp'.replace(/(\w+)\s(\w+)/, '$2 $1')
// 返回 Camp Code
```
